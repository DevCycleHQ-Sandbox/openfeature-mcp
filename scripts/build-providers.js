#!/usr/bin/env node

/**
 * Script to bundle providers metadata into a TypeScript file
 * Similar to build-prompts.js, this allows us to include provider
 * information at build time for environments without file system access.
 *
 * Usage:
 *   OPENFEATURE_PROVIDERS_DIR=/path/to/openfeature.dev/src/datasets/providers \
 *   node scripts/build-providers.js
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OUTPUT_FILE = path.join(__dirname, '..', 'src', 'tools', 'providersBundle.generated.ts');

function getProvidersDir() {
  // Allow override via env var. If not set, we can't discover providers.
  const envDir = process.env.OPENFEATURE_PROVIDERS_DIR;
  if (envDir && envDir.trim()) return envDir.trim();
  return null;
}

async function listProviderFiles(dir) {
  try {
    const files = await fs.readdir(dir);
    return files.filter(f => f.endsWith('.ts'));
  } catch (err) {
    console.warn('‚ö†Ô∏è  Could not read providers directory:', err?.message || err);
    return [];
  }
}

async function readProviderFile(filePath) {
  try {
    return await fs.readFile(filePath, 'utf-8');
  } catch (err) {
    console.warn(`‚ö†Ô∏è  Could not read provider file: ${path.basename(filePath)}`);
    return null;
  }
}

function extractDocsUrl(fileContent) {
  // Heuristic: prefer URLs assigned to fields named url/link/docs or inside an object with key 'url'.
  const urlFieldRegex = /(url|link|docs)\s*:\s*['"](https?:\/\/[^'"\s)]+)['"]/i;
  const match = fileContent.match(urlFieldRegex);
  if (match) return match[2];

  // Fallback: first http(s) URL in the file
  const anyUrlRegex = /https?:\/\/[^'"\s)]+/i;
  const anyMatch = fileContent.match(anyUrlRegex);
  return anyMatch ? anyMatch[0] : '';
}

function extractSupportedTechnologies(fileContent) {
  // Heuristic: look for arrays of strings under keys like supportedTechnologies/technologies/sdks/languages
  const arrayRegexes = [
    /supported\s*(technologies|sdks|sdksList|languages)?\s*:\s*\[([\s\S]*?)\]/i,
    /technologies\s*:\s*\[([\s\S]*?)\]/i,
    /sdks\s*:\s*\[([\s\S]*?)\]/i,
    /languages\s*:\s*\[([\s\S]*?)\]/i,
  ];
  for (const re of arrayRegexes) {
    const m = fileContent.match(re);
    if (m) {
      const inner = m[m.length - 1];
      const items = inner
        .split(',')
        .map(s => s.trim())
        .map(s => s.replace(/^['"]|['"]$/g, ''))
        .filter(Boolean);
      if (items.length) return items;
    }
  }
  // Fallback: empty list
  return [];
}

function normalizeTechnologyName(name) {
  // Normalize common tech names to match our install guide keys if possible
  const n = name.toLowerCase();
  switch (n) {
    case 'js':
    case 'javascript':
      return 'javascript';
    case 'node':
    case 'nodejs':
      return 'nodejs';
    case 'react':
      return 'react';
    case 'java':
      return 'java';
    case 'go':
    case 'golang':
      return 'go';
    case 'python':
      return 'python';
    case 'ruby':
      return 'ruby';
    case 'php':
      return 'php';
    case 'android':
      return 'android';
    case 'ios':
      return 'ios';
    case 'dotnet':
    case '.net':
    case 'c#':
      return 'dotnet';
    case 'nestjs':
      return 'nestjs';
    default:
      return n;
  }
}

async function buildProvidersBundle() {
  console.log('üî® Building providers bundle...');
  const providersDir = getProvidersDir();
  const result = [];

  if (!providersDir) {
    console.warn('‚ö†Ô∏è  OPENFEATURE_PROVIDERS_DIR not set. Generating empty providers bundle.');
  } else {
    const files = await listProviderFiles(providersDir);
    for (const file of files) {
      const full = path.join(providersDir, file);
      const content = await readProviderFile(full);
      if (!content) continue;
      const base = path.basename(file, '.ts');
      const docsUrl = extractDocsUrl(content);
      const techs = extractSupportedTechnologies(content).map(normalizeTechnologyName);
      result.push({ name: base, docsUrl, technologies: Array.from(new Set(techs)) });
      console.log(`‚úÖ ${base}: Parsed`);
    }
  }

  // Generate TypeScript file
  const providerNames = result.map(r => r.name);
  const hasProviders = providerNames.length > 0;
  const providersArray = providerNames.map(p => `  '${p}',`).join('\n');
  const supportEntries = result
    .map(r => `  '${r.name}': { docsUrl: ${JSON.stringify(r.docsUrl)}, supportedGuides: [${r.technologies.map(t => `'${t}'`).join(', ')}] as typeof INSTALL_GUIDES[number][] },`)
    .join('\n');

  const tsContent = `// AUTO-GENERATED FILE - Do not edit manually
// Generated by scripts/build-providers.js

import { z } from 'zod';
import { INSTALL_GUIDES } from './promptsBundle.generated.js';

export const PROVIDERS = [
${providersArray}
] as const;

export type ProviderName = ${hasProviders ? "typeof PROVIDERS[number]" : "string"};

export const providersSchema = z.array(${hasProviders ? "z.enum(PROVIDERS)" : "z.string()"}).default([]);

export const PROVIDER_SUPPORT: Record<ProviderName${hasProviders ? '' : ' | string'}, { docsUrl: string; supportedGuides: typeof INSTALL_GUIDES[number][] }> = {
${supportEntries}
};
`;

  await fs.writeFile(OUTPUT_FILE, tsContent, 'utf-8');
  console.log(`\nüìÑ Output: ${path.relative(process.cwd(), OUTPUT_FILE)}`);
  console.log(`üéâ Providers bundle created with ${result.length} provider(s).`);
}

async function main() {
  try {
    await buildProvidersBundle();
  } catch (error) {
    console.error('‚ùå Error building providers bundle:', error);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { buildProvidersBundle };

